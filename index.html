<!DOCTYPE html>
<html lang="nb">
<head>
  <meta charset="UTF-8" />
  <title>MultiProperty Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Plugin for prosenttekst inne i kakestykkene -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <style>
    :root {
      --primary: #0069d9;
      --success: #28a745;
      --danger: #e74c3c;
      --warning: #ffc107;
      --light: #f8f9fa;
      --dark: #343a40;
      --gray: #6c757d;
      --border: #dee2e6;
    }
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
      color: #333;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 18px 24px;
      border-bottom: 1px solid var(--border);
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 18px;
      position: relative;
      z-index: 10;
    }
    .title-container {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 300px;
    }
    .logo {
      width: 144px;
      height: 144px;
      border-radius: 8px;
      object-fit: contain;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      background: #fff;
      padding: 4px;
    }
    .title-block {
      display: flex;
      flex-direction: column;
    }
    .title {
      font-size: 22px;
      font-weight: 700;
      color: var(--primary);
      margin: 0;
    }
    .org {
      font-size: 15px;
      font-weight: 600;
      color: var(--dark);
      margin-top: -4px;
    }
    .dev {
      font-size: 12px;
      color: var(--gray);
      margin-top: -2px;
      font-style: italic;
    }
    .subtitle {
      font-size: 14px;
      color: var(--gray);
      font-style: italic;
      margin-left: auto;
      white-space: nowrap;
    }
    label {
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      white-space: nowrap;
    }
    select, button {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 14px;
      transition: all 0.2s ease;
    }
    select {
      background: white;
      min-width: 180px;
      max-width: 260px;
    }
    select:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 105, 217, 0.15);
      outline: none;
    }
    button {
      background: var(--primary);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    button#scanButton { background: var(--success); }
    button#scanButton:hover:not(:disabled) { background: #218838; }
    button#resetButton { background: var(--danger); }
    button#resetButton:hover:not(:disabled) { background: #c0392b; }
    button#colorizeButton { background: #00c2cb; }
    button#colorizeButton:hover:not(:disabled) { background: #00a0aa; }
    button:disabled {
      background: var(--gray);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      opacity: 0.85;
    }
    .prop-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    main {
      flex: 1;
      padding: 24px;
      overflow-y: auto;
      display: grid;
      gap: 28px;
      grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
      justify-items: center;
    }
    .chart-card {
      background: white;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      padding: 28px 24px 22px 24px;
      width: 100%;
      max-width: 550px;
      text-align: center;
      transition: transform 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .chart-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary), #00c2cb);
      border-radius: 16px 16px 0 0;
    }
    .chart-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 32px rgba(0,0,0,0.18);
    }
    .chart-card h3 {
      margin: 4px 0 16px 0;
      font-size: 18px;
      color: var(--dark);
      font-weight: 600;
      word-break: break-word;
    }
    .chart-summary {
      margin-top: 8px;
      font-size: 13px;
      color: var(--gray);
    }
    canvas {
      max-height: 320px;
      border-radius: 12px;
    }
    #status, #error {
      grid-column: 1 / -1;
      text-align: center;
      font-size: 15px;
      padding: 10px 14px;
      border-radius: 8px;
    }
    #status {
      background: rgba(40, 167, 69, 0.1);
      color: var(--success);
      border: 1px solid rgba(40, 167, 69, 0.2);
    }
    #error {
      background: rgba(220, 53, 69, 0.08);
      color: var(--danger);
      border: 1px solid rgba(220, 53, 69, 0.15);
      display: none;
    }
    .footer-credit {
      grid-column: 1 / -1;
      text-align: center;
      font-size: 14px;
      color: #888;
      margin-top: 8px;
      font-style: italic;
    }
    .button-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }

    .detail-container {
      margin-top: 12px;
      text-align: left;
      background: #fafafa;
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid #eeeeee;
      max-height: 260px;
      overflow: auto;
      font-size: 12px;
    }
    .detail-section {
      margin-bottom: 10px;
    }
    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      gap: 8px;
      flex-wrap: wrap;
    }
    .detail-header span {
      font-weight: 600;
      color: var(--dark);
    }
    .detail-header small {
      color: var(--gray);
      font-weight: 400;
    }
    .export-btn {
      padding: 6px 10px;
      border-radius: 6px;
      border: none;
      font-size: 11px;
      cursor: pointer;
      background: var(--primary);
      color: #fff;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .export-btn:hover {
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    .detail-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .detail-table th,
    .detail-table td {
      padding: 3px 5px;
      border-bottom: 1px solid #e4e4e4;
      text-align: left;
      white-space: nowrap;
    }
    .detail-table th {
      position: sticky;
      top: 0;
      background: #f0f0f0;
      z-index: 1;
      font-weight: 600;
    }
    .detail-table tbody tr:nth-child(even) {
      background: #fdfdfd;
    }
    .detail-empty {
      font-size: 12px;
      color: var(--gray);
      padding: 4px 0;
    }
    .detail-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    @media (max-width: 1024px) {
      header {
        flex-direction: column;
        align-items: stretch;
      }
      .title-container {
        justify-content: center;
      }
      .subtitle {
        margin-left: 0;
        text-align: center;
      }
      .prop-group {
        justify-content: center;
      }
      .button-row {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="title-container">
      <img src="norconsult-logo-black.png"
           alt="Norconsult logo" class="logo">

      <div class="title-block">
        <h1 class="title">MultiProperty Checker</h1>
        <div class="org">Norconsult Norge</div>
        <div class="dev">Developed by Edin Dzakmic, Norconsult, (AI-assisted development)</div>
      </div>
    </div>

    <span class="subtitle">Opptil 4 egenskaper samtidig</span>

    <label>
      Property Set:
      <select id="psetSelect" disabled>
        <option value="">(velgâ€¦)</option>
      </select>
    </label>

    <div class="prop-group">
      <label>
        <input type="checkbox" id="cb1">
        Property 1:
        <select id="prop1" disabled>
          <option value="">(ingen)</option>
        </select>
      </label>
      <label>
        <input type="checkbox" id="cb2">
        Property 2:
        <select id="prop2" disabled>
          <option value="">(ingen)</option>
        </select>
      </label>
      <label>
        <input type="checkbox" id="cb3">
        Property 3:
        <select id="prop3" disabled>
          <option value="">(ingen)</option>
        </select>
      </label>
      <label>
        <input type="checkbox" id="cb4">
        Property 4:
        <select id="prop4" disabled>
          <option value="">(ingen)</option>
        </select>
      </label>
    </div>

    <div class="button-row">
      <button id="scanButton" disabled>ðŸ”„ Oppdater liste</button>
      <button id="loadButton" disabled>ðŸ“Š Hent diagrammer</button>
      <button id="colorizeButton" disabled>ðŸŽ¨ Fargelegg alle</button>
      <button id="resetButton" disabled>ðŸ”„ Tilbakestill</button>
    </div>
  </header>

  <main>
    <div id="status">Kobler til Trimble Connectâ€¦</div>
    <div id="error"></div>
    <div id="chartsContainer"></div>
    <div class="footer-credit">
      MultiProperty Checker â€“ Property completeness-oversikt direkte i modellen.<br>
      Klikk pÃ¥ et kakestykke for Ã¥ markere objekter i modellen og vise tabeller med objekter (med / uten verdi) og eksportere til CSV.
    </div>
  </main>

  <script>
    let API = null;
    let availableProps = {};
    let charts = [];
    let lastSelections = new Map(); // for fargelegging

    const COLORS = {
      withValue: "rgb(46, 204, 113)",
      withoutValue: "rgb(231, 76, 60)"
    };

    const els = {
      status: document.getElementById("status"),
      error: document.getElementById("error"),
      chartsContainer: document.getElementById("chartsContainer"),
      psetSelect: document.getElementById("psetSelect"),
      scanButton: document.getElementById("scanButton"),
      loadButton: document.getElementById("loadButton"),
      colorizeButton: document.getElementById("colorizeButton"),
      resetButton: document.getElementById("resetButton")
    };

    const propSelectIds = ["prop1", "prop2", "prop3", "prop4"];
    const cbIds = ["cb1", "cb2", "cb3", "cb4"];

    // Registrer datalabels-plugin for prosenttekst inne i kakestykkene
    if (window.ChartDataLabels) {
      Chart.register(ChartDataLabels);
    }

    function showError(msg) {
      els.error.textContent = msg || "";
      els.error.style.display = msg ? "block" : "none";
    }

    function setBusy(isBusy) {
      const buttons = [
        els.scanButton,
        els.loadButton,
        els.colorizeButton,
        els.resetButton
      ];
      buttons.forEach(btn => {
        if (!btn) return;
        if (isBusy) {
          btn.dataset.prevDisabled = btn.disabled ? "true" : "false";
          btn.disabled = true;
        } else if (btn.dataset.prevDisabled === "false") {
          btn.disabled = false;
        }
      });
    }

    async function connect() {
      try {
        API = await TrimbleConnectWorkspace.connect(window.parent, () => {}, 30000);
        els.status.textContent = "âœ… Tilkoblet â€“ trykk Â«Oppdater listeÂ» for Ã¥ hente Property Sets.";
        els.scanButton.disabled = false;
      } catch (e) {
        showError("Kunne ikke koble til Trimble Connect: " + (e && e.message ? e.message : e));
        els.status.textContent = "âŒ Feil ved tilkobling.";
      }
    }

    function clearCharts() {
      charts.forEach(c => c.destroy());
      charts = [];
      els.chartsContainer.innerHTML = "";
      // lastSelections beholdes for farge-reset
    }

    function resetPropertySelectors() {
      const selects = propSelectIds.map(id => document.getElementById(id));
      const cbs = cbIds.map(id => document.getElementById(id));
      selects.forEach(s => {
        s.innerHTML = '<option value="">(ingen)</option>';
        s.disabled = true;
      });
      cbs.forEach(cb => {
        cb.checked = false;
      });
    }

    function populatePropSelects(pset) {
      resetPropertySelectors();
      if (!pset || !availableProps[pset]) return;

      const props = Array.from(availableProps[pset]).sort((a, b) => a.localeCompare(b, "nb"));
      const selects = propSelectIds.map(id => document.getElementById(id));

      selects.forEach(sel => {
        props.forEach(p => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = p;
          sel.appendChild(opt);
        });
        sel.disabled = false;
      });
    }

    async function scanProperties() {
      if (!API) {
        showError("API ikke klar. Vent et Ã¸yeblikk og prÃ¸v igjen.");
        return;
      }

      clearCharts();
      showError("");
      availableProps = {};
      els.loadButton.disabled = true;
      els.colorizeButton.disabled = true;
      els.resetButton.disabled = true;

      els.status.textContent = "ðŸ” Skanner modell for Property Setsâ€¦";
      setBusy(true);

      try {
        const models = await API.viewer.getObjects();
        if (!models || !models.length) {
          els.status.textContent = "â„¹ï¸ Fant ingen objekter i visningen. SÃ¸rg for at modell(er) er innlastet.";
          setBusy(false);
          return;
        }

        for (const m of models) {
          const modelId = m.modelId || m.modelid || m["model Id"];
          const objs = m.objects || [];
          if (!modelId || !objs.length) continue;

          const runtimeIds = objs.map(o => o.id);
          if (!runtimeIds.length) continue;

          const objProps = await API.viewer.getObjectProperties(modelId, runtimeIds);
          for (const obj of objProps || []) {
            for (const pset of obj.properties || []) {
              const name = pset.name || "";
              if (!name) continue;
              if (!availableProps[name]) availableProps[name] = new Set();
              for (const p of pset.properties || []) {
                if (p.name) availableProps[name].add(p.name);
              }
            }
          }
        }

        const sel = els.psetSelect;
        sel.innerHTML = '<option value="">(velgâ€¦)</option>';
        const psetNames = Object.keys(availableProps);

        if (!psetNames.length) {
          els.status.textContent = "â„¹ï¸ Ingen Property Sets funnet pÃ¥ objektene i visningen.";
          sel.disabled = true;
        } else {
          psetNames.sort((a, b) => a.localeCompare(b, "nb")).forEach(n => {
            const opt = document.createElement("option");
            opt.value = n;
            opt.textContent = n;
            sel.appendChild(opt);
          });
          sel.disabled = false;
          els.status.textContent = "âœ… Ferdig skannet â€“ velg Property Set og huk av opptil 4 properties.";
          els.loadButton.disabled = false;
        }
      } catch (e) {
        showError("Feil under skanning av egenskaper: " + (e && e.message ? e.message : e));
        els.status.textContent = "âŒ Klarte ikke Ã¥ skanne egenskaper.";
      } finally {
        setBusy(false);
      }
    }

    function extractGuidFromObject(obj) {
      let guid = obj.guid || obj.GlobalId || "";

      if (obj.properties && obj.properties.length) {
        for (const ps of obj.properties) {
          const psName = (ps.name || "").toLowerCase();
          if (psName === "component attributes" || psName === "componentattributes") {
            for (const p of ps.properties || []) {
              const pn = (p.name || "").toLowerCase();
              if (
                pn === "guid" ||
                pn === "ifc guid" || pn === "ifcguid" ||
                pn === "globalid" || pn === "global id"
              ) {
                if (p.value) return String(p.value);
              }
            }
          }
        }

        if (!guid) {
          for (const ps of obj.properties) {
            for (const p of ps.properties || []) {
              const pn = (p.name || "").toLowerCase();
              if (
                pn === "guid" ||
                pn === "ifc guid" || pn === "ifcguid" ||
                pn === "globalid" || pn === "global id"
              ) {
                if (p.value) return String(p.value);
              }
            }
          }
        }
      }

      return guid || "";
    }

    async function getPropertyData(psetName, propName) {
      const counts = { withValue: 0, withoutValue: 0 };
      const selection = { withValue: {}, withoutValue: {} };
      const details = { withValue: {}, withoutValue: {} };

      const models = await API.viewer.getObjects();
      if (!models || !models.length) return { counts, selection, details };

      for (const m of models) {
        const modelId = m.modelId || m.modelid || m["model Id"];
        const objs = m.objects || [];
        if (!modelId || !objs.length) continue;

        const runtimeIds = objs.map(o => o.id);
        if (!runtimeIds.length) continue;

        const objProps = await API.viewer.getObjectProperties(modelId, runtimeIds);

        for (const obj of objProps || []) {
          let hasProp = false;
          let hasVal = false;
          const psetProps = {};

          for (const ps of obj.properties || []) {
            if (ps.name !== psetName) continue;

            for (const p of ps.properties || []) {
              const pname = p.name;
              const val = p.value;
              psetProps[pname] = val;

              if (pname === propName) {
                hasProp = true;
                if (val !== null && val !== undefined && String(val).trim() !== "") {
                  hasVal = true;
                }
              }
            }
          }

          const key = hasProp && hasVal ? "withValue" : "withoutValue";
          counts[key]++;

          if (!selection[key][modelId]) selection[key][modelId] = [];
          selection[key][modelId].push(obj.id);

          const objectInfo = {
            modelId,
            runtimeId: obj.id,
            name: obj.name || obj.objectName || "",
            guid: extractGuidFromObject(obj),
            properties: psetProps
          };

          if (!details[key][modelId]) details[key][modelId] = [];
          details[key][modelId].push(objectInfo);
        }
      }

      return { counts, selection, details };
    }

    function escapeCSV(value) {
      if (value === null || value === undefined) return "";
      const str = String(value);
      if (/[;\n\r"]/.test(str)) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      return str;
    }

    function exportSliceToCSV(pset, prop, sliceType, detailPerModel) {
      const objects = [];
      for (const modelId in detailPerModel) {
        const arr = detailPerModel[modelId] || [];
        arr.forEach(o => objects.push(o));
      }

      if (!objects.length) {
        showError("Ingen objekter Ã¥ eksportere for valgt gruppe.");
        return;
      }

      const allPropNamesSet = new Set();
      objects.forEach(o => {
        Object.keys(o.properties || {}).forEach(pn => allPropNamesSet.add(pn));
      });

      const allPropNames = Array.from(allPropNamesSet).sort((a, b) => a.localeCompare(b, "nb"));

      const baseCols = ["#", "ModelId", "RuntimeId", "ObjectName", "ObjectGuid", "SliceType", "PropertySet"];
      const header = baseCols.concat(allPropNames);

      const rows = [];
      rows.push(header.join(";"));

      const sliceLabel = sliceType === "withValue" ? "Med verdi" : "Uten verdi";

      objects.forEach((o, index) => {
        const row = {
          "#": index + 1,
          ModelId: o.modelId || "",
          RuntimeId: o.runtimeId || "",
          ObjectName: o.name || "",
          ObjectGuid: o.guid || "",
          SliceType: sliceLabel,
          PropertySet: pset
        };

        allPropNames.forEach(pn => {
          row[pn] = (o.properties && pn in o.properties) ? o.properties[pn] : "";
        });

        const rowValues = header.map(col => escapeCSV(row[col]));
        rows.push(rowValues.join(";"));
      });

      const csvContent = rows.join("\r\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");

      const dateStr = new Date().toISOString().slice(0, 10);
      const sliceShort = sliceType === "withValue" ? "medVerdi" : "utenVerdi";
      link.href = url;
      link.download = `TC_${pset}_${prop}_${sliceShort}_${dateStr}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      els.status.textContent =
        `ðŸ“¤ Eksporterte ${objects.length} objekter til CSV (${sliceLabel}) for ${pset} â†’ ${prop}.`;
      showError("");
    }

    function buildDetailSection(pset, prop, sliceType, details, parent) {
      const detailPerModel = details[sliceType] || {};
      const objects = [];
      for (const modelId in detailPerModel) {
        const arr = detailPerModel[modelId] || [];
        arr.forEach(o => objects.push(o));
      }

      const sliceLabel = sliceType === "withValue" ? "Med verdi" : "Uten verdi/mangler property";

      const section = document.createElement("div");
      section.className = "detail-section";

      const title = document.createElement("div");
      title.className = "detail-title";
      title.textContent = sliceLabel;
      section.appendChild(title);

      const headerDiv = document.createElement("div");
      headerDiv.className = "detail-header";

      const infoSpan = document.createElement("span");
      if (!objects.length) {
        infoSpan.textContent = "Ingen objekter i denne gruppen.";
      } else {
        infoSpan.textContent = `Antall objekter: ${objects.length}`;
      }

      const infoSmall = document.createElement("small");
      infoSmall.textContent = "Kolonner: #, ModelId, RuntimeId, GUID, Navn, Verdi for valgt property.";

      const leftInfo = document.createElement("div");
      leftInfo.style.display = "flex";
      leftInfo.style.flexDirection = "column";
      leftInfo.appendChild(infoSpan);
      leftInfo.appendChild(infoSmall);

      headerDiv.appendChild(leftInfo);

      if (objects.length) {
        const exportBtn = document.createElement("button");
        exportBtn.className = "export-btn";
        exportBtn.innerHTML = "ðŸ“¤ Eksporter til CSV";
        exportBtn.onclick = () => exportSliceToCSV(pset, prop, sliceType, detailPerModel);
        headerDiv.appendChild(exportBtn);
      }

      section.appendChild(headerDiv);

      if (!objects.length) {
        const emptyDiv = document.createElement("div");
        emptyDiv.className = "detail-empty";
        emptyDiv.textContent = "Ingen objekt Ã¥ vise for denne gruppen.";
        section.appendChild(emptyDiv);
        parent.appendChild(section);
        return;
      }

      const table = document.createElement("table");
      table.className = "detail-table";

      const thead = document.createElement("thead");
      const headRow = document.createElement("tr");
      ["#", "ModelId", "RuntimeId", "ObjectGuid", "ObjectName", prop].forEach(col => {
        const th = document.createElement("th");
        th.textContent = col;
        headRow.appendChild(th);
      });
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      objects.forEach((o, index) => {
        const tr = document.createElement("tr");
        const val = o.properties ? o.properties[prop] : "";

        const cells = [
          index + 1,
          o.modelId || "",
          o.runtimeId || "",
          o.guid || "",
          o.name || "",
          val !== undefined && val !== null ? val : ""
        ];

        cells.forEach(c => {
          const td = document.createElement("td");
          td.textContent = c;
          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      section.appendChild(table);
      parent.appendChild(section);
    }

    function showBothSlicesDetails(pset, prop, details, detailContainer) {
      detailContainer.innerHTML = "";
      buildDetailSection(pset, prop, "withValue", details, detailContainer);
      buildDetailSection(pset, prop, "withoutValue", details, detailContainer);
    }

    // Marker objekter i modellen for valgt kakestykke (withValue / withoutValue)
    async function highlightSliceInModel(selection, sliceType) {
      if (!API) return;

      const perModel = selection[sliceType] || {};
      const modelObjectIds = [];
      let totalObjects = 0;

      for (const modelId in perModel) {
        const ids = perModel[modelId];
        if (ids && ids.length) {
          modelObjectIds.push({ modelId, objectRuntimeIds: ids });
          totalObjects += ids.length;
        }
      }

      if (!modelObjectIds.length) {
        els.status.textContent =
          sliceType === "withValue"
            ? "Ingen objekter med verdi Ã¥ markere."
            : "Ingen objekter uten verdi/mangler property Ã¥ markere.";
        return;
      }

      try {
        await API.viewer.setSelection({ modelObjectIds }, "replace");
        els.status.textContent =
          sliceType === "withValue"
            ? `ðŸ”Ž Markerte ${totalObjects} objekter MED verdi i modellen.`
            : `ðŸ”Ž Markerte ${totalObjects} objekter UTEN verdi/mangler property i modellen.`;
      } catch (e) {
        showError("Feil ved markering av objekter: " + (e && e.message ? e.message : e));
      }
    }

    function createPieChart(pset, prop, counts, details, selection) {
      const total = counts.withValue + counts.withoutValue;
      const container = els.chartsContainer;

      const card = document.createElement("div");
      card.className = "chart-card";

      const title = document.createElement("h3");
      title.textContent = `${pset} â†’ ${prop}`;
      card.appendChild(title);

      const canvas = document.createElement("canvas");
      card.appendChild(canvas);

      const summary = document.createElement("div");
      summary.className = "chart-summary";

      const pctWith = total ? ((counts.withValue / total) * 100).toFixed(1) : "0.0";
      const pctWithout = total ? ((counts.withoutValue / total) * 100).toFixed(1) : "0.0";
      summary.textContent =
        `Totalt ${total} objekter â€¢ Med verdi: ${counts.withValue} (${pctWith} %) â€¢ ` +
        `Uten verdi/mangler property: ${counts.withoutValue} (${pctWithout} %). ` +
        `Klikk pÃ¥ et kakestykke for Ã¥ markere objekter og vise tabeller.`;
      card.appendChild(summary);

      const detailContainer = document.createElement("div");
      detailContainer.className = "detail-container";
      card.appendChild(detailContainer);

      container.appendChild(card);

      const chart = new Chart(canvas, {
        type: "pie",
        data: {
          labels: ["Med verdi", "Uten verdi"],
          datasets: [{
            data: [counts.withValue, counts.withoutValue],
            backgroundColor: [COLORS.withValue, COLORS.withoutValue],
            borderColor: "#fff",
            borderWidth: 4,
            hoverOffset: 12
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: "bottom",
              labels: {
                font: { size: 14 },
                padding: 20,
                usePointStyle: true
              }
            },
            tooltip: {
              callbacks: {
                label: ctx => {
                  const v = ctx.parsed;
                  const pct = total ? (v / total * 100).toFixed(1) : 0;
                  return `${ctx.label}: ${pct}% (${v} objekter)`;
                }
              }
            },
            // Prosenttekst inne i kakestykkene
            datalabels: {
              formatter: value => {
                const pct = total ? (value / total * 100).toFixed(1) : 0;
                return `${pct} %`;
              },
              color: "#fff",
              font: {
                weight: "bold",
                size: 14
              },
              anchor: "center",
              align: "center",
              clamp: true,
              clip: false
            }
          },
          animation: {
            animateRotate: true,
            duration: 900
          },
          // Klikk pÃ¥ kakestykke â†’ marker objekter i modellen + vis tabeller
          onClick: (event, elements) => {
            if (!elements || !elements.length) return;
            const index = elements[0].index;
            const sliceType = index === 0 ? "withValue" : "withoutValue";

            // Marker objekter i modellen for denne gruppen
            highlightSliceInModel(selection, sliceType);

            // Vis begge tabeller (med og uten verdi) under diagrammet
            showBothSlicesDetails(pset, prop, details, detailContainer);
          }
        }
      });

      charts.push(chart);
    }

    async function loadAllCharts() {
      if (!API) {
        showError("API ikke klar. Vent et Ã¸yeblikk og prÃ¸v igjen.");
        return;
      }

      clearCharts();
      showError("");

      const pset = els.psetSelect.value;
      if (!pset) {
        showError("Velg et Property Set fÃ¸rst.");
        return;
      }

      const selectedProps = [];
      for (let i = 1; i <= 4; i++) {
        const cb = document.getElementById(`cb${i}`);
        const sel = document.getElementById(`prop${i}`);
        if (cb.checked && sel && sel.value) {
          selectedProps.push(sel.value);
        }
      }

      if (!selectedProps.length) {
        showError("Huk av minst Ã©n property for Ã¥ lage kakediagram.");
        return;
      }

      els.status.textContent = `ðŸ“ˆ Laster ${selectedProps.length} kakediagramâ€¦`;
      els.colorizeButton.disabled = true;
      els.resetButton.disabled = true;
      setBusy(true);

      try {
        for (const prop of selectedProps) {
          const { counts, selection, details } = await getPropertyData(pset, prop);
          lastSelections.set(prop, selection);
          createPieChart(pset, prop, counts, details, selection);
        }

        els.status.textContent =
          `âœ… ${selectedProps.length} kakediagram ferdig! Klikk pÃ¥ et kakestykke for Ã¥ markere objekter ` +
          `og vise tabeller med objekter (med / uten verdi) og eksportere til CSV.`;
        els.colorizeButton.disabled = false;
        els.resetButton.disabled = false;
      } catch (e) {
        showError("Feil ved henting av kakediagram: " + (e && e.message ? e.message : e));
        els.status.textContent = "âŒ Klarte ikke Ã¥ generere kakediagram.";
      } finally {
        setBusy(false);
      }
    }

    async function colorizeAll() {
      if (!API) return;
      if (!lastSelections.size) {
        showError("Ingen aktive utvalg Ã¥ fargelegge. Generer kakediagram fÃ¸rst.");
        return;
      }

      showError("");
      els.status.textContent = "ðŸŽ¨ Fargelegger objekter i modellenâ€¦";
      setBusy(true);

      try {
        await API.viewer.setObjectState(undefined, { color: "reset" });

        for (const [, sel] of lastSelections) {
          for (const state of ["withValue", "withoutValue"]) {
            const perModel = sel[state];
            const list = [];

            for (const modelId in perModel) {
              if (perModel[modelId].length) {
                list.push({ modelId, objectRuntimeIds: perModel[modelId] });
              }
            }

            if (!list.length) continue;

            const rgba = state === "withValue"
              ? { r: 46, g: 204, b: 113, a: 255 }
              : { r: 231, g: 76, b: 60, a: 255 };

            await API.viewer.setObjectState({ modelObjectIds: list }, { color: rgba });
          }
        }

        els.status.textContent =
          "ðŸŽ¨ Alle valgte properties er fargelagt i modellen (grÃ¸nn = med verdi, rÃ¸d = uten verdi/mangler).";
        els.resetButton.disabled = false;
      } catch (e) {
        showError("Feil ved fargelegging: " + (e && e.message ? e.message : e));
        els.status.textContent = "âŒ Klarte ikke Ã¥ fargelegge objekter.";
      } finally {
        setBusy(false);
      }
    }

    async function resetAll() {
      if (!API) return;

      setBusy(true);
      showError("");
      clearCharts();

      try {
        await API.viewer.setObjectState(undefined, { color: "reset" });
        els.status.textContent =
          "ðŸ”„ Modellen er tilbakestilt til originalfarger. Du kan fortsatt generere nye kakediagram med samme valg.";
      } catch (e) {
        showError("Feil ved tilbakestilling av modellfarger: " + (e && e.message ? e.message : e));
        els.status.textContent = "âŒ Klarte ikke Ã¥ tilbakestille modellfarger.";
      } finally {
        els.colorizeButton.disabled = true;
        els.resetButton.disabled = true;
        els.loadButton.disabled = false;
        setBusy(false);
      }
    }

    cbIds.forEach((cbId, index) => {
      const cb = document.getElementById(cbId);
      const sel = document.getElementById(propSelectIds[index]);
      cb.addEventListener("change", () => {
        if (!sel) return;
        if (!cb.checked) {
          sel.value = "";
        }
      });
    });

    els.scanButton.onclick = scanProperties;
    els.loadButton.onclick = loadAllCharts;
    els.colorizeButton.onclick = colorizeAll;
    els.resetButton.onclick = resetAll;

    els.psetSelect.onchange = e => {
      clearCharts();
      showError("");
      populatePropSelects(e.target.value);
      els.colorizeButton.disabled = true;
      els.resetButton.disabled = true;
    };

    connect();
  </script>
</body>
</html>
